// Digital Twin Service - AI-Powered Vendor Representation
const Vendor = require('../models/Vendor');
const logger = require('../utils/logger');

class VendorDigitalTwin {
    constructor(vendorId) {
        this.vendorId = vendorId;
        this.profile = null;
        this.aiAgent = new VendorAIAgent(vendorId);
    }

    // Create or update digital twin from WhatsApp input
    async processVendorInput(phone, message, messageType = 'text', mediaData = null) {
        try {
            console.log(`ðŸ¤– Processing ${messageType} input from ${phone}`);
            
            // Extract structured data using AI
            const extractedData = await this.aiAgent.extractStructuredData(message, messageType, mediaData);
            
            // Find or create vendor
            let vendor = await Vendor.findOne({ phone });
            
            if (!vendor) {
                // Create new digital twin
                vendor = await this.createDigitalTwin(phone, extractedData);
                console.log(`âœ¨ Created new digital twin for ${phone}`);
            } else {
                // Update existing digital twin
                vendor = await this.updateDigitalTwin(vendor, extractedData);
                console.log(`ðŸ”„ Updated digital twin for ${phone}`);
            }
            
            // Generate AI response
            const response = await this.aiAgent.generateResponse(extractedData, vendor, message);
            
            return {
                vendor,
                response,
                extractedData
            };
            
        } catch (error) {
            logger.error('Digital twin processing error:', error);
            throw error;
        }
    }

    // Create new digital twin
    async createDigitalTwin(phone, data) {
        // Normalize phone number (remove non-digits)
        const normalizedPhone = phone.replace(/\D/g, '');
        
        // Generate proper coordinates for the vendor
        let coordinates = [77.5946, 12.9716]; // Default: Bangalore
        
        // Try to get better coordinates based on location text
        if (data.locationText) {
            const locationCoords = await this.geocodeLocation(data.locationText);
            if (locationCoords && locationCoords.coordinates) {
                coordinates = locationCoords.coordinates;
            }
        } else {
            // Add some randomization to default coordinates
            coordinates = [
                77.5946 + (Math.random() - 0.5) * 0.1,
                12.9716 + (Math.random() - 0.5) * 0.1
            ];
        }

        const vendorData = {
            phone: normalizedPhone, // Store normalized phone
            name: data.name || `Vendor ${normalizedPhone.slice(-4)}`,
            businessName: data.businessName || data.name || `Business ${normalizedPhone.slice(-4)}`,
            category: data.category || 'other',
            products: data.products || [],
            location: {
                type: 'Point',
                coordinates: coordinates,
                address: { street: data.locationText || 'Location via WhatsApp' }
            },
            
            // Ensure vendor appears on map
            lat: coordinates[1],
            lng: coordinates[0],
            
            // Digital presence metadata
            digitalPresence: {
                hasOnlinePresence: true,
                whatsappEnabled: true,
                autoGenerated: true,
                createdAt: new Date(),
                lastUpdated: new Date(),
                totalOrders: 0,
                completedOrders: 0,
                rating: { average: 0, count: 0 }
            },
            
            // Vendor status - auto-verified via WhatsApp
            isCurrentlyOpen: true,
            isVerified: true, // WhatsApp provides authentication
            status: 'active',
            onboardingSource: 'whatsapp',
            createdVia: 'whatsapp',
            
            // Payment methods
            paymentMethods: {
                cash: true,
                upi: true,
                upiId: normalizedPhone.slice(-10) + '@paytm'
            },
            
            // AI agent configuration
            aiAgent: {
                enabled: true,
                language: data.language || 'en',
                personality: 'friendly',
                responseStyle: 'concise'
            }
        };

        const vendor = new Vendor(vendorData);
        await vendor.save();
        
        console.log(`âœ… Created vendor ${vendor.name} at coordinates [${coordinates[0]}, ${coordinates[1]}]`);
        console.log(`ðŸ“± Vendor identity: Phone ${normalizedPhone} (WhatsApp authenticated)`);
        
        return vendor;
    }

    // Update existing digital twin
    async updateDigitalTwin(vendor, data) {
        let updated = false;

        // Update name if provided
        if (data.name && data.name !== vendor.name) {
            vendor.name = data.name;
            updated = true;
        }

        // Update products
        if (data.products && data.products.length > 0) {
            // Add new products or update existing ones
            data.products.forEach(newProduct => {
                const existingProduct = vendor.products.find(p => 
                    p.name.toLowerCase() === newProduct.name.toLowerCase()
                );
                
                if (existingProduct) {
                    // Update existing product
                    existingProduct.price = newProduct.price;
                    existingProduct.available = newProduct.available !== false;
                } else {
                    // Add new product
                    vendor.products.push({
                        ...newProduct,
                        _id: undefined, // Let MongoDB generate ID
                        available: newProduct.available !== false
                    });
                }
            });
            updated = true;
        }

        // Update location if provided
        if (data.locationText) {
            vendor.location = await this.geocodeLocation(data.locationText);
            updated = true;
        }

        // Update availability status
        if (data.status) {
            vendor.isCurrentlyOpen = data.status === 'open';
            updated = true;
        }

        // Update category if inferred
        if (data.category && data.category !== vendor.category) {
            vendor.category = data.category;
            updated = true;
        }

        if (updated) {
            vendor.digitalPresence.lastUpdated = new Date();
            await vendor.save();
        }

        return vendor;
    }

    // Handle customer queries via AI agent
    async handleCustomerQuery(vendorId, query, customerContext = {}) {
        try {
            const vendor = await Vendor.findById(vendorId);
            if (!vendor) {
                throw new Error('Vendor not found');
            }

            const response = await this.aiAgent.answerCustomerQuery(query, vendor, customerContext);
            
            // Log interaction for analytics
            vendor.analytics.customerInteractions = (vendor.analytics.customerInteractions || 0) + 1;
            await vendor.save();

            return response;
            
        } catch (error) {
            logger.error('Customer query handling error:', error);
            return "Sorry, I couldn't process your query right now. Please try again.";
        }
    }

    // Geocode location text to coordinates
    async geocodeLocation(locationText) {
        try {
            // In production, use Google Maps Geocoding API
            // For demo, return approximate coordinates based on common locations
            const locationMap = {
                'mg road': [77.6033, 12.9759],
                'brigade road': [77.6082, 12.9719],
                'koramangala': [77.6309, 12.9279],
                'indiranagar': [77.6408, 12.9784],
                'whitefield': [77.7499, 12.9698],
                'electronic city': [77.6648, 12.8456],
                'jp nagar': [77.5833, 12.9083],
                'btm layout': [77.6100, 12.9165]
            };

            const lowerLocation = locationText.toLowerCase();
            for (const [key, coords] of Object.entries(locationMap)) {
                if (lowerLocation.includes(key)) {
                    return {
                        type: 'Point',
                        coordinates: coords,
                        address: { street: locationText }
                    };
                }
            }

            // Default location with slight randomization
            return {
                type: 'Point',
                coordinates: [
                    77.5946 + (Math.random() - 0.5) * 0.1,
                    12.9716 + (Math.random() - 0.5) * 0.1
                ],
                address: { street: locationText }
            };
            
        } catch (error) {
            logger.error('Geocoding error:', error);
            return {
                type: 'Point',
                coordinates: [77.5946, 12.9716],
                address: { street: locationText }
            };
        }
    }
}

// AI Agent for individual vendors
class VendorAIAgent {
    constructor(vendorId) {
        this.vendorId = vendorId;
    }

    // Extract structured data from unstructured input
    async extractStructuredData(message, messageType, mediaData) {
        const data = {};

        if (messageType === 'text') {
            // Extract name - improved regex
            const namePatterns = [
                /(?:i'm|i am|my name is|name is)\s+([a-zA-Z\s]{2,30}?)(?:\s+and|\s+,|$)/i,
                /^hi,?\s+i\s+am\s+([a-zA-Z\s]{2,30}?)(?:\s+and|\s+,|$)/i,
                /^([a-zA-Z\s]{2,30}?)\s+(?:here|speaking|calling)/i
            ];
            
            for (const pattern of namePatterns) {
                const match = message.match(pattern);
                if (match) {
                    data.name = match[1].trim();
                    break;
                }
            }

            // Extract products using enhanced regex
            data.products = this.extractProducts(message);

            // Extract location - improved regex
            const locationPatterns = [
                /(?:at|near|in|from)\s+([a-zA-Z\s,]{3,50}?)(?:\s+and|\s+,|$)/i,
                /location[:\s]+([a-zA-Z\s,]{3,50}?)(?:\s+and|\s+,|$)/i,
                /address[:\s]+([a-zA-Z\s,]{3,50}?)(?:\s+and|\s+,|$)/i
            ];
            
            for (const pattern of locationPatterns) {
                const match = message.match(pattern);
                if (match) {
                    data.locationText = match[1].trim();
                    break;
                }
            }

            // Infer category from products
            if (data.products.length > 0) {
                data.category = this.inferCategory(data.products);
            }

            // Detect status changes
            if (message.toLowerCase().includes('closed') || message.toLowerCase().includes('close')) {
                data.status = 'closed';
            } else if (message.toLowerCase().includes('open')) {
                data.status = 'open';
            }

        } else if (messageType === 'voice') {
            // In production, use speech-to-text API
            // For demo, treat as text
            return this.extractStructuredData(message, 'text');
            
        } else if (messageType === 'image') {
            // In production, use computer vision API
            // For demo, return sample products
            data.products = [
                { name: 'Item 1', price: 20, description: 'From image' },
                { name: 'Item 2', price: 30, description: 'From image' }
            ];
        }

        return data;
    }

    // Extract products from text using improved regex
    extractProducts(text) {
        const products = [];
        
        // Enhanced patterns for product extraction
        const patterns = [
            // "samsung s25 ultra â‚¹50,000" or "samosa â‚¹15"
            /([a-zA-Z][a-zA-Z\s\d]{1,35}?)\s+â‚¹\s*([\d,]+)/g,
            // "samsung s25 ultra rs 50,000" or "samosa rs 15"
            /([a-zA-Z][a-zA-Z\s\d]{1,35}?)\s+rs\.?\s*([\d,]+)/gi,
            // "samsung s25 ultra rupees 50000" or "samosa rupees 15"
            /([a-zA-Z][a-zA-Z\s\d]{1,35}?)\s+rupees?\s*([\d,]+)/gi,
            // "samsung s25 ultra - 50,000" (careful pattern)
            /([a-zA-Z][a-zA-Z\s\d]{1,35}?)\s*-\s*([\d,]+)(?!\d)/g
        ];
        
        patterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(text)) !== null) {
                const name = match[1].trim();
                const priceStr = match[2].replace(/,/g, '');
                const price = parseInt(priceStr);
                
                // Validation
                if (name.length > 1 && 
                    name.length < 40 && 
                    price > 0 && 
                    price < 1000000 && 
                    !this.isCommonWord(name)) {
                    
                    products.push({
                        name: this.capitalizeFirst(name),
                        price: price,
                        description: `${name}`,
                        available: true,
                        category: this.inferProductCategory(name)
                    });
                }
            }
        });
        
        return this.deduplicateProducts(products);
    }

    // Generate AI response based on extracted data
    async generateResponse(extractedData, vendor, originalMessage = '') {
        if (!vendor) {
            // New vendor onboarding
            if (extractedData.name && extractedData.products.length > 0) {
                const productList = extractedData.products.map(p => `â€¢ ${p.name} - â‚¹${p.price}`).join('\n');
                return `ðŸŽ‰ Welcome ${extractedData.name}! Your digital store is being created...\n\nðŸ“¦ Products found:\n${productList}\n\nâœ¨ Your store will be live in a moment!`;
            } else if (extractedData.name) {
                return `Hello ${extractedData.name}! ðŸ‘‹\n\nNow tell me what you sell and the prices.\n\nExample: "Samosa 15 rupees, Tea 10 rupees"`;
            } else {
                return `ðŸ™ Welcome to VendorGo!\n\nI'll help you create your digital store in 2 minutes.\n\nWhat's your name or business name?`;
            }
        } else {
            // Check if this is a new vendor with products just created
            if (extractedData.products.length > 0 && vendor.products.length <= extractedData.products.length) {
                const productList = extractedData.products.map(p => `â€¢ ${p.name} - â‚¹${p.price}`).join('\n');
                const storeUrl = `http://localhost:3000/store/${vendor._id}`;
                
                if (vendor.products.length === extractedData.products.length) {
                    // First time creating store
                    return `ðŸŽ‰ Congratulations ${vendor.name}!\n\nYour digital store is LIVE!\n\nðŸ”— Your store: ${storeUrl}\n\nðŸ“¦ Products:\n${productList}\n\nâœ… Customers can now:\nâ€¢ Find you online\nâ€¢ See your products\nâ€¢ Order & pay instantly\n\nðŸ’¡ Add more products anytime or type "help" for options!`;
                } else {
                    // Adding more products
                    return `âœ… Added new products to your store!\n\nðŸ“¦ New items:\n${productList}\n\nðŸ”— Your store: ${storeUrl}\n\nðŸ’¡ Keep adding products or type "help" for more options!`;
                }
            }
            
            // Existing vendor updates
            if (extractedData.products.length > 0) {
                const productList = extractedData.products.map(p => `â€¢ ${p.name} - â‚¹${p.price}`).join('\n');
                return `âœ… Updated your store!\n\n${productList}\n\nCustomers can see these changes now.`;
            } else if (extractedData.status) {
                return `âœ… Status updated to ${extractedData.status}.\n\nCustomers will see your current availability.`;
            } else {
                // Handle non-product messages for existing vendors
                if (originalMessage.toLowerCase().includes('done') || originalMessage.toLowerCase().includes('finish') || originalMessage.toLowerCase().includes('complete')) {
                    const storeUrl = `http://localhost:3000/store/${vendor._id}`;
                    return `âœ… Perfect! Your store is already live and ready!\n\nðŸ”— Your store: ${storeUrl}\n\nðŸ“Š Current status:\nâ€¢ ${vendor.products.length} products listed\nâ€¢ Store is ${vendor.isCurrentlyOpen ? 'OPEN' : 'CLOSED'}\nâ€¢ Ready for orders!\n\nðŸ’¡ You can always add more products or update your status!`;
                }
                
                // Show products list
                if (originalMessage.toLowerCase().includes('show products') || originalMessage.toLowerCase().includes('list products') || originalMessage.toLowerCase().includes('my products')) {
                    if (!vendor.products || vendor.products.length === 0) {
                        return `ðŸ“¦ You don't have any products yet.\n\nAdd products by typing:\n"Product Name â‚¹Price"\n\nExample: "Samosa â‚¹15"`;
                    }
                    
                    const productList = vendor.products.map((p, index) => 
                        `${index + 1}. ${p.name} - â‚¹${p.price}`
                    ).join('\n');
                    
                    return `ðŸ“¦ Your Products:\n\n${productList}\n\nðŸ’¡ Commands:\nâ€¢ Add: "Product Name â‚¹Price"\nâ€¢ Delete: "delete [product name]"\nâ€¢ Help: "help"`;
                }
                
                // Delete product
                if (originalMessage.toLowerCase().includes('delete ')) {
                    const productName = originalMessage.substring(originalMessage.toLowerCase().indexOf('delete ') + 7).trim();
                    
                    if (!vendor.products || vendor.products.length === 0) {
                        return `âŒ No products found to delete.`;
                    }
                    
                    const productIndex = vendor.products.findIndex(p => 
                        p.name.toLowerCase().includes(productName.toLowerCase())
                    );
                    
                    if (productIndex === -1) {
                        return `âŒ Product "${productName}" not found.\n\nType "show products" to see your product list.`;
                    }
                    
                    // Remove product from vendor
                    const deletedProduct = vendor.products.splice(productIndex, 1)[0];
                    await vendor.save();
                    
                    return `âœ… Deleted "${deletedProduct.name}" from your store.\n\nRemaining products: ${vendor.products.length}\n\nType "show products" to see updated list.`;
                }
                
                // Help command
                if (originalMessage.toLowerCase().includes('help')) {
                    return `ðŸ†˜ VendorGo Help:\n\nâ€¢ "show products" - View all products\nâ€¢ "delete [name]" - Remove product\nâ€¢ "[product] â‚¹[price]" - Add new items\nâ€¢ "orders" - Check recent orders\nâ€¢ Customer App: http://localhost:3000/\n\nWhat do you need help with?`;
                }
                
                return `Hi ${vendor.name}! ðŸ‘‹\n\nYour store is running well. How can I help you today?\n\nâ€¢ Add products: "Add samosa 15 rupees"\nâ€¢ Update status: "Closed today"\nâ€¢ View store: "show my store"\nâ€¢ Get help: "help"`;
            }
        }
    }

    // Answer customer queries
    async answerCustomerQuery(query, vendor, customerContext) {
        const lowerQuery = query.toLowerCase();
        
        // Availability queries
        if (lowerQuery.includes('open') || lowerQuery.includes('available')) {
            if (vendor.isCurrentlyOpen) {
                return `Yes, ${vendor.name} is currently open! ðŸŸ¢\n\nWe have ${vendor.products.filter(p => p.available).length} items available.`;
            } else {
                return `Sorry, ${vendor.name} is currently closed. ðŸ”´\n\nPlease check back later!`;
            }
        }
        
        // Product queries
        if (lowerQuery.includes('menu') || lowerQuery.includes('items') || lowerQuery.includes('products')) {
            const availableProducts = vendor.products.filter(p => p.available);
            if (availableProducts.length > 0) {
                const productList = availableProducts.map(p => `â€¢ ${p.name} - â‚¹${p.price}`).join('\n');
                return `ðŸ“‹ Here's what we have:\n\n${productList}\n\nWhat would you like to order?`;
            } else {
                return `Sorry, no items are available right now. Please check back later!`;
            }
        }
        
        // Price queries
        const priceMatch = lowerQuery.match(/price.*?([a-zA-Z\s]+)/);
        if (priceMatch) {
            const itemName = priceMatch[1].trim();
            const product = vendor.products.find(p => 
                p.name.toLowerCase().includes(itemName) || itemName.includes(p.name.toLowerCase())
            );
            if (product) {
                return `${product.name} costs â‚¹${product.price}. ${product.available ? 'Available now!' : 'Currently out of stock.'}`;
            } else {
                return `Sorry, I couldn't find "${itemName}" in our menu. Type "menu" to see all items.`;
            }
        }
        
        // Location queries
        if (lowerQuery.includes('location') || lowerQuery.includes('address') || lowerQuery.includes('where')) {
            return `ðŸ“ ${vendor.name} is located at:\n${vendor.location.address.street}\n\nYou can find us on the map in the app!`;
        }
        
        // Default response
        return `Hi! I'm the AI assistant for ${vendor.name}. ðŸ¤–\n\nI can help you with:\nâ€¢ Menu and prices\nâ€¢ Availability\nâ€¢ Location\n\nWhat would you like to know?`;
    }

    // Utility methods
    inferCategory(products) {
        const foodKeywords = ['samosa', 'tea', 'chai', 'coffee', 'food', 'snack', 'meal', 'rice', 'curry', 'bread'];
        const electronicsKeywords = ['phone', 'mobile', 'samsung', 'iphone', 'laptop', 'tablet', 'charger', 'headphone'];
        const clothingKeywords = ['shirt', 'pant', 'dress', 'saree', 'kurta', 'jeans', 'top'];
        
        const productNames = products.map(p => p.name.toLowerCase()).join(' ');
        
        if (foodKeywords.some(keyword => productNames.includes(keyword))) return 'food';
        if (electronicsKeywords.some(keyword => productNames.includes(keyword))) return 'electronics';
        if (clothingKeywords.some(keyword => productNames.includes(keyword))) return 'clothing';
        
        return 'other';
    }

    inferProductCategory(productName) {
        return this.inferCategory([{ name: productName }]);
    }

    isCommonWord(word) {
        const common = ['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'this', 'that', 'these', 'those', 'my', 'your', 'his', 'her', 'our', 'their', 'sell', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'can', 'may', 'might', 'must', 'done', 'want', 'need', 'like', 'get', 'got', 'make', 'made'];
        return common.includes(word.toLowerCase()) || word.length < 2;
    }

    capitalizeFirst(str) {
        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    }

    deduplicateProducts(products) {
        const seen = new Set();
        return products.filter(product => {
            const key = product.name.toLowerCase();
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
        });
    }
}

module.exports = { VendorDigitalTwin, VendorAIAgent };